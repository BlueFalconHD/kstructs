from __future__ import annotations

from .dwarf_emit_types import CType, StructDecl, TypeRegistry
from .dwarf_emit_utils import _is_synthetic_member_name, _resolve_typedef


def render_type(
    registry: TypeRegistry,
    type_ref: CType,
    name: str,
    expand_typedefs: bool,
) -> str:
    if expand_typedefs:
        type_ref = _resolve_typedef(registry, type_ref, set())

    if type_ref.kind == "named":
        base = type_ref.name or "void"
        if type_ref.ref_kind in {"struct", "union", "enum"}:
            if type_ref.ref_kind == "enum" and type_ref.name in registry.enums:
                enum_decl = registry.enums[type_ref.name]
                if enum_decl.typedef_as is not None:
                    base = enum_decl.typedef_as
                else:
                    base = f"{type_ref.ref_kind} {base}"
            else:
                base = f"{type_ref.ref_kind} {base}"
        if type_ref.qualifiers:
            base = " ".join(type_ref.qualifiers) + " " + base
        if name:
            return f"{base} {name}"
        return base

    if type_ref.kind == "pointer":
        quals = " ".join(type_ref.qualifiers)
        if name:
            inner = f"*{name}" if not quals else f"* {quals} {name}"
        else:
            inner = "*" if not quals else f"* {quals}"
        if type_ref.target and type_ref.target.needs_parens():
            inner = f"({inner})"
        return render_type(registry, type_ref.target or CType(kind="named", name="void", ref_kind="base"), inner, expand_typedefs)

    if type_ref.kind == "array":
        count = "" if type_ref.count is None else str(type_ref.count)
        inner = f"{name}[{count}]" if name else f"[{count}]"
        return render_type(registry, type_ref.target or CType(kind="named", name="void", ref_kind="base"), inner, expand_typedefs)

    return "void"


def _collect_value_deps(registry: TypeRegistry, type_ref: CType) -> set[tuple[str, str]]:
    resolved = _resolve_typedef(registry, type_ref, set())
    if resolved.kind == "named":
        if resolved.ref_kind in {"struct", "union", "enum"}:
            if resolved.name:
                return {(resolved.ref_kind, resolved.name)}
        return set()
    if resolved.kind == "pointer":
        return set()
    if resolved.kind == "array":
        if resolved.target is None:
            return set()
        return _collect_value_deps(registry, resolved.target)
    return set()


def _sorted_decl_keys(registry: TypeRegistry) -> list[tuple[str, str]]:
    decls: dict[tuple[str, str], object] = {}
    for key, value in registry.structs.items():
        decls[key] = value
    for name in registry.enums:
        decls[("enum", name)] = registry.enums[name]

    deps: dict[tuple[str, str], set[tuple[str, str]]] = {}
    for key, decl in decls.items():
        if isinstance(decl, StructDecl):
            if decl.opaque:
                deps[key] = set()
                continue
            refs: set[tuple[str, str]] = set()
            for member in decl.members:
                inline_union = registry.inline_unions.get((decl.kind, decl.name, member.name))
                if inline_union is not None:
                    for submember in inline_union.members:
                        refs |= _collect_value_deps(registry, submember.type_ref)
                    continue
                inline_decl = registry.inline_members.get((decl.kind, decl.name, member.name))
                if inline_decl is not None:
                    for submember in inline_decl.members:
                        refs |= _collect_value_deps(registry, submember.type_ref)
                    continue
                refs |= _collect_value_deps(registry, member.type_ref)
            deps[key] = {ref for ref in refs if ref in decls}
        else:
            deps[key] = set()

    order: list[tuple[str, str]] = []
    visited: set[tuple[str, str]] = set()
    visiting: set[tuple[str, str]] = set()

    def visit(node: tuple[str, str]) -> None:
        if node in visited:
            return
        if node in visiting:
            return
        visiting.add(node)
        for dep in sorted(deps.get(node, [])):
            visit(dep)
        visiting.remove(node)
        visited.add(node)
        order.append(node)

    for key in sorted(decls):
        visit(key)
    return order


def render_c(registry: TypeRegistry) -> str:
    lines: list[str] = []
    lines.append("/* Generated by kstructs */")
    lines.append("#include <stddef.h>")
    lines.append("#include <stdint.h>")
    lines.append("#include <stdbool.h>")
    lines.append("")

    opaque_typedefs: set[str] = set()
    opaque_lines: list[str] = []
    for (kind, name), decl in sorted(registry.structs.items()):
        if not decl.opaque:
            continue
        opaque_lines.append(f"{kind} {name};")
        opaque_lines.append(f"typedef {kind} {name} {name};")
        opaque_typedefs.add(name)

    for name, enum_decl in sorted(registry.enums.items()):
        if not enum_decl.opaque:
            continue
        opaque_lines.append(f"enum {name};")
        opaque_lines.append(f"typedef enum {name} {name};")
        opaque_typedefs.add(name)

    if opaque_lines:
        lines.extend(opaque_lines)
        lines.append("")

    suppressed_unions = {decl.name for decl in registry.inline_unions.values() if decl.kind == "union"}
    suppressed_structs = {
        decl.name
        for decl in registry.inline_members.values()
        if decl.kind == "struct" and decl.name_origin in {"anon", "member"}
    }

    for key in _sorted_decl_keys(registry):
        kind, name = key
        if kind == "union" and name in suppressed_unions:
            continue
        if kind == "struct" and name in suppressed_structs:
            continue
        if kind == "enum":
            enum_decl = registry.enums[name]
            if enum_decl.opaque:
                continue
            if enum_decl.typedef_as is not None:
                lines.append("enum {")
            else:
                lines.append(f"enum {enum_decl.name} {{")
            for enum_name, value in enum_decl.enumerators:
                lines.append(f"    {enum_name} = {value},")
            lines.append("};")
            lines.append("")
            continue

        decl = registry.structs[key]
        if decl.opaque:
            continue
        lines.append(f"{decl.kind} {decl.name} {{")
        extra_asserts: list[tuple[str, int]] = []
        skip_members: set[str] = set()
        for member in decl.members:
            inline_union = registry.inline_unions.get((decl.kind, decl.name, member.name))
            if inline_union is not None:
                align_suffix = ""
                if member.alignment is not None:
                    align_suffix = f" __attribute__((aligned({member.alignment})))"
                packed_suffix = " __attribute__((packed))" if inline_union.packed else ""
                skip_members.add(member.name)
                lines.append("    union {")
                for submember in inline_union.members:
                    inline_decl = registry.inline_members.get((inline_union.kind, inline_union.name, submember.name))
                    if inline_decl is not None:
                        emit_anonymous = (
                            inline_decl.name_origin in {"anon", "member"}
                            and _is_synthetic_member_name(submember.name)
                        )
                        if member.offset is not None and submember.offset is not None:
                            if emit_anonymous:
                                for inline_member in inline_decl.members:
                                    if inline_member.offset is None or inline_member.bit_size is not None:
                                        continue
                                    extra_asserts.append(
                                        (inline_member.name, member.offset + submember.offset + inline_member.offset)
                                    )
                            else:
                                extra_asserts.append((submember.name, member.offset + submember.offset))
                        lines.append("        struct {")
                        for inline_member in inline_decl.members:
                            if inline_member.bit_size is not None:
                                decl_text = render_type(
                                    registry, inline_member.type_ref, inline_member.name, expand_typedefs=True
                                )
                                if inline_member.bit_offset is not None:
                                    lines.append(
                                        f"            {decl_text} : {inline_member.bit_size}; /* bit offset {inline_member.bit_offset} */"
                                    )
                                else:
                                    lines.append(f"            {decl_text} : {inline_member.bit_size};")
                            else:
                                decl_text = render_type(
                                    registry, inline_member.type_ref, inline_member.name, expand_typedefs=True
                                )
                                lines.append(f"            {decl_text};")
                        if emit_anonymous:
                            lines.append("        };")
                        else:
                            lines.append(f"        }} {submember.name};")
                        continue
                    if member.offset is not None and submember.offset is not None and submember.bit_size is None:
                        extra_asserts.append((submember.name, member.offset + submember.offset))
                    if submember.bit_size is not None:
                        decl_text = render_type(registry, submember.type_ref, submember.name, expand_typedefs=True)
                        if submember.bit_offset is not None:
                            lines.append(
                                f"        {decl_text} : {submember.bit_size}; /* bit offset {submember.bit_offset} */"
                            )
                        else:
                            lines.append(f"        {decl_text} : {submember.bit_size};")
                    else:
                        decl_text = render_type(registry, submember.type_ref, submember.name, expand_typedefs=True)
                        lines.append(f"        {decl_text};")
                lines.append(f"    }}{packed_suffix}{align_suffix};")
                continue
            inline_decl = registry.inline_members.get((decl.kind, decl.name, member.name))
            if inline_decl is not None:
                align_suffix = ""
                if member.alignment is not None:
                    align_suffix = f" __attribute__((aligned({member.alignment})))"
                packed_suffix = " __attribute__((packed))" if inline_decl.packed else ""
                emit_anonymous = inline_decl.name_origin in {"anon", "member"} and _is_synthetic_member_name(member.name)
                if emit_anonymous:
                    skip_members.add(member.name)
                    if member.offset is not None:
                        for submember in inline_decl.members:
                            if submember.offset is None or submember.bit_size is not None:
                                continue
                            extra_asserts.append((submember.name, member.offset + submember.offset))
                lines.append("    struct {")
                for submember in inline_decl.members:
                    if submember.bit_size is not None:
                        decl_text = render_type(registry, submember.type_ref, submember.name, expand_typedefs=True)
                        if submember.bit_offset is not None:
                            lines.append(f"        {decl_text} : {submember.bit_size}; /* bit offset {submember.bit_offset} */")
                        else:
                            lines.append(f"        {decl_text} : {submember.bit_size};")
                    else:
                        decl_text = render_type(registry, submember.type_ref, submember.name, expand_typedefs=True)
                        lines.append(f"        {decl_text};")
                if emit_anonymous:
                    lines.append(f"    }}{packed_suffix}{align_suffix};")
                else:
                    lines.append(f"    }}{packed_suffix} {member.name}{align_suffix};")
                continue
            if member.bit_size is not None:
                decl_text = render_type(registry, member.type_ref, member.name, expand_typedefs=True)
                if member.bit_offset is not None:
                    lines.append(f"    {decl_text} : {member.bit_size}; /* bit offset {member.bit_offset} */")
                else:
                    lines.append(f"    {decl_text} : {member.bit_size};")
            else:
                decl_text = render_type(registry, member.type_ref, member.name, expand_typedefs=True)
                if member.alignment is not None:
                    lines.append(f"    {decl_text} __attribute__((aligned({member.alignment})));")
                else:
                    lines.append(f"    {decl_text};")
        packed_suffix = " __attribute__((packed))" if decl.packed else ""
        lines.append(f"}}{packed_suffix};")

        if not decl.opaque:
            type_name = f"{decl.kind} {decl.name}"
            for member in decl.members:
                if member.name in skip_members:
                    continue
                if member.offset is None or member.bit_size is not None:
                    continue
                lines.append(
                    f"_Static_assert(offsetof({type_name}, {member.name}) == 0x{member.offset:x}, "
                    f"\"{decl.name}.{member.name} offset\");"
                )
            for member_name, offset in extra_asserts:
                lines.append(
                    f"_Static_assert(offsetof({type_name}, {member_name}) == 0x{offset:x}, "
                    f"\"{decl.name}.{member_name} offset\");"
                )
            if decl.kind == "struct" and decl.size is not None:
                lines.append(
                    f"_Static_assert(sizeof({type_name}) == 0x{decl.size:x}, \"{decl.name} size\");"
                )
        lines.append("")

    if registry.typedefs:
        for typedef_name in sorted(registry.typedefs):
            if typedef_name in opaque_typedefs:
                continue
            typedef = registry.typedefs[typedef_name]
            decl_text = render_type(registry, typedef.target, typedef.name, expand_typedefs=True)
            lines.append(f"typedef {decl_text};")

    return "\n".join(lines).rstrip() + "\n"
